--------------------------------------
Producer Consumer - 1/1
--------------------------------------


#include <stdio.h>
#include <stdlib.h>
#include <semaphore.h>
#include <pthread.h>
#include <unistd.h>

#define BUFF_SIZE 5
#define ITER 20

int buffer[BUFF_SIZE];
int in;
// in = 0;

pthread_cond_t Buffer_Not_Full=PTHREAD_COND_INITIALIZER;
pthread_cond_t Buffer_Not_Empty=PTHREAD_COND_INITIALIZER;
pthread_mutex_t mVar=PTHREAD_MUTEX_INITIALIZER;


void *produce (void *args) {
for (int i=0;i<ITER;i++) {
		pthread_mutex_lock(&mVar);
        if(in>=BUFF_SIZE)
        {                        
            pthread_cond_wait(&Buffer_Not_Full,&mVar);
        } 
        buffer[in++]=1;
        printf("Produced at : %d \n", in);
        pthread_mutex_unlock(&mVar);
        pthread_cond_signal(&Buffer_Not_Empty);                        
	}
}


void *consume(void *args) {
for (int i=0;i<ITER;i++) {
		pthread_mutex_lock(&mVar);
int *consumer = (int *)args;
       if(in<=0)
        {            
            pthread_cond_wait(&Buffer_Not_Empty,&mVar);
        }                
        printf("Consumed by c%d, from : %d \n", *consumer, in--);        
        pthread_mutex_unlock(&mVar);        
        pthread_cond_signal(&Buffer_Not_Full);
	}
}


int main(int argc, char const *argv[])
{
pthread_t pro, con1;
	int c1;
	c1 = 1;
pthread_create(&pro, NULL, produce, NULL);
	pthread_create(&con1, NULL, consume, (void*) &c1);
pthread_join(pro, NULL);
	pthread_join(con1, NULL);
return 0;
}

--------------------------------------
PRODUCER CONSUMER - 1/2:
--------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <semaphore.h>
#include <pthread.h>
#include <unistd.h>

#define BUFF_SIZE 5
#define ITER 20

int buffer[BUFF_SIZE];
int in;
// in = 0;

pthread_cond_t Buffer_Not_Full=PTHREAD_COND_INITIALIZER;
pthread_cond_t Buffer_Not_Empty=PTHREAD_COND_INITIALIZER;
pthread_mutex_t mVar=PTHREAD_MUTEX_INITIALIZER;


void *produce (void *args) {
	
	for (int i=0;i<ITER;i++) {
		pthread_mutex_lock(&mVar);
        if(in>=BUFF_SIZE)
        {                        
            pthread_cond_wait(&Buffer_Not_Full,&mVar);
        } 
        buffer[in++]=1;
        printf("Produced at : %d \n", in);
        pthread_mutex_unlock(&mVar);
        pthread_cond_signal(&Buffer_Not_Empty);                        
	}
}


void *consume(void *args) {

	for (int i=0;i<ITER;i++) {
		pthread_mutex_lock(&mVar);

		int *consumer = (int *)args;

        if(in<=0)
        {            
            pthread_cond_wait(&Buffer_Not_Empty,&mVar);
        }                
        printf("Consumed by c%d, from : %d \n", *consumer, in--);        
        pthread_mutex_unlock(&mVar);        
        pthread_cond_signal(&Buffer_Not_Full);
	}
}


int main(int argc, char const *argv[])
{

	pthread_t pro, con1, con2;
	int c1, c2;
	c1 = 1;
    c2 = 2;

	pthread_create(&pro, NULL, produce, NULL);
	pthread_create(&con1, NULL, consume, (void*) &c1);
	pthread_create(&con2, NULL, consume, (void*) &c2);

	pthread_join(pro, NULL);
	pthread_join(con1, NULL);
    pthread_join(con2, NULL);

	return 0;
}

--------------------------------------
  PRODUCER CONSUMER - 2/1:  
--------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <semaphore.h>
#include <pthread.h>
#include <unistd.h>

#define BUFF_SIZE 3
#define ITER 43

int buffer[BUFF_SIZE];
int in;
// in = 0;

pthread_cond_t Buffer_Not_Full=PTHREAD_COND_INITIALIZER;
pthread_cond_t Buffer_Not_Empty=PTHREAD_COND_INITIALIZER;
pthread_mutex_t mVar=PTHREAD_MUTEX_INITIALIZER;


void *produce (void *args) {
	
	
	
	for (int i=0;i<ITER;i++) {
		pthread_mutex_lock(&mVar);
		
		int *producer = (int *)args;
		
        if(in>=BUFF_SIZE)
        {                        
            pthread_cond_wait(&Buffer_Not_Full,&mVar);
        } 
        buffer[in++]=1;
        printf("Produced at : %d by producer : %d \n", in, *producer);
        pthread_mutex_unlock(&mVar);
        pthread_cond_signal(&Buffer_Not_Empty);                        
	}
}


void *consume(void *args) {

	for (int i=0;i<ITER;i++) {
		pthread_mutex_lock(&mVar);

		int *consumer = (int *)args;

        if(in<=0)
        {            
            pthread_cond_wait(&Buffer_Not_Empty,&mVar);
        }                
        printf("Consumed by c%d, from : %d \n", *consumer, in--);        
        pthread_mutex_unlock(&mVar);        
        pthread_cond_signal(&Buffer_Not_Full);
	}
}


int main(int argc, char const *argv[])
{

	pthread_t pro1, pro2, con1, con2;
	int c1, c2;
	int p1, p2;
	p1 =1; p2 = 2;
	c1 = 1;
    //c2 = 2;

	pthread_create(&pro1, NULL, produce, (void*) &p1);
	pthread_create(&pro2, NULL, produce, (void*) &p2);
	pthread_create(&con1, NULL, consume, (void*) &c1);
	//pthread_create(&con2, NULL, consume, (void*) &c2);

	pthread_join(pro1, NULL);
	pthread_join(pro2,NULL);
	pthread_join(con1, NULL);
    //pthread_join(con2, NULL);

	return 0;
}

--------------------------------------
PRODUCER CONSUMER 2/2:
--------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <semaphore.h>
#include <pthread.h>
#include <unistd.h>

#define BUFF_SIZE 3
#define ITER 43

int buffer[BUFF_SIZE];
int in;
// in = 0;

pthread_cond_t Buffer_Not_Full=PTHREAD_COND_INITIALIZER;
pthread_cond_t Buffer_Not_Empty=PTHREAD_COND_INITIALIZER;
pthread_mutex_t mVar=PTHREAD_MUTEX_INITIALIZER;


void *produce (void *args) {
	
	
	
	for (int i=0;i<ITER;i++) {
		pthread_mutex_lock(&mVar);
		
		int *producer = (int *)args;
		
        if(in>=BUFF_SIZE)
        {                        
            pthread_cond_wait(&Buffer_Not_Full,&mVar);
        } 
        buffer[in++]=1;
        printf("Produced at : %d by producer : %d \n", in, *producer);
        pthread_mutex_unlock(&mVar);
        pthread_cond_signal(&Buffer_Not_Empty);                        
	}
}


void *consume(void *args) {

	for (int i=0;i<ITER;i++) {
		pthread_mutex_lock(&mVar);

		int *consumer = (int *)args;

        if(in<=0)
        {            
            pthread_cond_wait(&Buffer_Not_Empty,&mVar);
        }                
        printf("Consumed by c%d, from : %d \n", *consumer, in--);        
        pthread_mutex_unlock(&mVar);        
        pthread_cond_signal(&Buffer_Not_Full);
	}
}


int main(int argc, char const *argv[])
{

	pthread_t pro1, pro2, con1, con2;
	int c1, c2;
	int p1, p2;
	p1 =1; p2 = 2;
	c1 = 1;
    //c2 = 2;

	pthread_create(&pro1, NULL, produce, (void*) &p1);
	pthread_create(&pro2, NULL, produce, (void*) &p2);
	pthread_create(&con1, NULL, consume, (void*) &c1);
	//pthread_create(&con2, NULL, consume, (void*) &c2);

	pthread_join(pro1, NULL);
	pthread_join(pro2,NULL);
	pthread_join(con1, NULL);
    //pthread_join(con2, NULL);

	return 0;
}
--------------------------------------
PRODUCER / CONSUMER : N/N
--------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <semaphore.h>
#include <pthread.h>
#include <unistd.h>

#define BUFF_SIZE 3
#define ITER 43
#define n1 4
#define n2 5

int buffer[BUFF_SIZE];
int in;
// in = 0;

pthread_cond_t Buffer_Not_Full=PTHREAD_COND_INITIALIZER;
pthread_cond_t Buffer_Not_Empty=PTHREAD_COND_INITIALIZER;
pthread_mutex_t mVar=PTHREAD_MUTEX_INITIALIZER;


void *produce (void *args) {
	
	
	
	for (int i=0;i<ITER;i++) {
		pthread_mutex_lock(&mVar);
		
		int producer = (int *)args;
		
        if(in>=BUFF_SIZE)
        {                        
            pthread_cond_wait(&Buffer_Not_Full,&mVar);
        } 
        buffer[in++]=1;
        printf("Produced at : %d by producer : %d \n", in, producer);
        pthread_mutex_unlock(&mVar);
        pthread_cond_signal(&Buffer_Not_Empty);                        
	}
}


void *consume(void *args) {

	for (int i=0;i<ITER;i++) {
		pthread_mutex_lock(&mVar);

		int consumer = (int *)args;

        if(in<=0)
        {            
            pthread_cond_wait(&Buffer_Not_Empty,&mVar);
        }                
        printf("Consumed by c%d, from : %d \n", consumer, in--);        
        pthread_mutex_unlock(&mVar);        
        pthread_cond_signal(&Buffer_Not_Full);
	}
}


int main(int argc, char const *argv[])
{

	pthread_t pro[n1], con[n2];
	int c[n1] , p[n2];
    int i;
    
    for(i=0;i<n1;i++)
    {
    int j = i+1;
	pthread_create(&pro[i], NULL, produce, (void*) j);
    }
    for(i=0;i<n2;i++)
    {
    int j = i+1;
	pthread_create(&con[i], NULL, consume, (void*) j);
    }
    
    for(i=0;i<n1;i++)
    {
	pthread_join(pro[i], NULL);
    }
	
	for(i=0;i<n2;i++)
    {
	pthread_join(con[i], NULL);
    }


	return 0;
}

--------------------------------------
Reader / Writer : 
--------------------------------------

#include<stdio.h>
#include<pthread.h>
#include<semaphore.h>

sem_t mutex,writeblock;
int data = 0,rcount = 0;

void *reader(void *arg)
{
  int f;
  f = ((int)arg);
  printf("\nReader %d is trying to enter",f);
  sem_wait(&mutex);
  rcount = rcount + 1;
  if(rcount==1)
   sem_wait(&writeblock);
   printf("\nReader %d entered",f);
  sem_post(&mutex);
  printf("\nData read by the reader %d - %d",f,data);
  sleep(1);
  sem_wait(&mutex);
  rcount = rcount - 1;
  if(rcount==0)
   sem_post(&writeblock);
  sem_post(&mutex);
 printf("\nReader %d left",f);
}

void *writer(void *arg)
{
  int f;
  f = ((int) arg);
  printf("\nWriter %d is trying to enter",f);
  sem_wait(&writeblock);
 printf("\nWriter %d entered",f);
  data++;
  printf("\nData writen by the writer %d - %d",f,data);
  sleep(1);
  sem_post(&writeblock);
   printf("\nWriter %d left",f);
}

int main()
{
  int i,b; 
  pthread_t rtid[5],wtid[5];
  sem_init(&mutex,0,1);
  sem_init(&writeblock,0,1);
  for(i=0;i<=2;i++)
  {
    pthread_create(&wtid[i],NULL,writer,(void *)i);
    pthread_create(&rtid[i],NULL,reader,(void *)i);
  }
  for(i=0;i<=2;i++)
  {
    pthread_join(wtid[i],NULL);
    pthread_join(rtid[i],NULL);
  }
    //pthread_create(&wtid[3],NULL,writer,(void *)3);
    //pthread_create(&rtid[3],NULL,reader,(void *)3);
   // pthread_join(wtid[3],NULL);
    //pthread_join(rtid[3],NULL);
    
  return 0;
}


------------------------------------------------
Multi Paging System  and Translation of VA-PA: 
------------------------------------------------

#include<bits/stdc++.h>
using namespace std;

int main ()
{

    int mm[8][128] = { 0 };
    map < int, int >pid_pgsize;
    map <int, int> pid_drsize;
    map< int,int> pid_prsize;
    int pid = 0;
    
    int rem;
    int c;
    
    
    std::list<int> free_pgs;
    
    for(int i=10;i<118;i++)
    {
        free_pgs.push_back(i);
    }
    
    while (1)
        {
            cout << "OPTIONS:\n";
            cout << "1.Create process\n";
            cout << "2.Delete process\n";
            cout << "3.Translation VA-PA of process\n";
            cout << "4.Print MM\n";
            cout << "5.Exit\n";
            cin >> c;
    switch (c)
    	{
    	case 1:
        int pr_size, pg_nos,no_full_pagetable,rem_half_pagetable;
        cout << "Enter Process Size:\n";
        cin >> pr_size;
        pid_prsize[pid] = pr_size;
        
        if (pr_size == 0)
        pg_nos = 0;
        
        else if (pr_size <= 8)
        pg_nos = 1;
        
        else if ((pr_size > 8) && (pr_size % 8 == 0))
        pg_nos = pr_size / 8;
        
        else
        {
            pg_nos = pr_size / 8 + 1;
            rem = pr_size % 8;
        }
        
            
        
        if (pg_nos > 0 && pg_nos <= 8 )
        {
            
            if (free_pgs.size() - pg_nos >= 0)
            {
                pid_pgsize[pid] = pg_nos;
                cout<<"\nImplemented Single-Level paging\n";
                for (int i = 0; i < pg_nos; i++)
                {
                    
                            mm[i][pid] = free_pgs.front();
                            free_pgs.pop_front();
                            
                            if(i==pg_nos-1)
                            {
                                for(int k = 0 ; k<rem;k++)
                                mm[k][mm[i][pid]]=1;
                            }
                            else 
                            {
                                for(int k = 0 ; k<8;k++)
                                    mm[k][mm[i][pid]]=1;
                            }
                }
                cout<<"\nProcess "<<pid<<" Created !!\n";
                pid++;
            }
            else
            {
                cout<<"\nImplementing LRU Policy\n-------- under construction--------\n";
                
            }
        }
          
          
              
        else if (pg_nos > 0 && pg_nos > 8 && pg_nos<=64)
        {
           
            cout<<"\nImplemented Multi-Level paging\n";
              
            int pg_dr,x,j,req_pg;
            if (pg_nos%8 ==0) pg_dr = pg_nos / 8;
            else pg_dr = pg_nos / 8 + 1;
           
            pid_drsize[pid]= pg_dr;
            pid_pgsize[pid] = pg_nos;
            
           if(free_pgs.size() - pg_nos - pg_dr >=0 )
           {
            
                for(int p=0;p<pg_dr;p++)
                {
                    mm[p][pid]=free_pgs.front();
                    free_pgs.pop_front();
                }
                
                no_full_pagetable = pg_nos/8;
                rem_half_pagetable = pg_nos%8;
                
                for(int p=0;p<no_full_pagetable;p++)
                {
                    for(int i=0;i<8;i++)
                    {
                        mm[i][mm[p][pid]] = free_pgs.front();
                        free_pgs.pop_front();
                        for(int y=0;y<8;y++)
                        {
                            mm[y][mm[i][mm[p][pid]]]=1;
                        }
                    }
                }
               
                for(int k = 0;k<rem_half_pagetable;k++)
                {
                    mm[k][mm[pg_dr-1][pid]] = free_pgs.front();
                    free_pgs.pop_front();
                    
                    for(int p = 0; p<8,k!=rem_half_pagetable-1;p++)
                    {
                        mm[p][mm[k][mm[pg_dr-1][pid]]]=1;
                    }
                    if(k==rem_half_pagetable-1)
                    {
                        for(int p=0;p<pid_prsize[pid]%8;p++)
                        {
                            mm[p][mm[k][mm[pg_dr-1][pid]]]=1;
                        }
                    }
                    
                    
                }
                cout<<"\nProcess "<<pid<<" Created !!\n";
                pid++;
           }
        }
        
        else
        {
            cout<<" Can't be allocated !! Requested Process size exceeds the max limit!";
            
        }
        
        break;
    
    	case 2:
            int del_id;
            cout << "\nEnter Process ID:\n";
            cin >> del_id;
            int i;
           
           if(pid_pgsize[del_id]<=8)
           {
               for(i=0;i<pid_pgsize[del_id];i++)
                {
                    int val = mm[i][del_id];
            	    cout<<"\n\n";
            	    
                    for(int k=0;k<8;k++)
                    {
                        mm[k][val]=0;
                    }
                    
                    free_pgs.push_back(mm[i][del_id]);
                    mm[i][del_id] = 0;
                }
                pid_pgsize[del_id]=0;
                cout<<"\nProcess "<<del_id<<" Deleted!!\n";
           }
           
           else
           {
               cout<<"\nProcess "<<del_id<<" started to delete!!\n";
               for(int i=0;i< pid_drsize[del_id];i++)
               {
                   int dir_table = mm[i][del_id];
                   
                   if(i != pid_drsize[del_id]-1)
                   {
                        for(int k=0;k<8;k++)
                            {
                                int pg_table = mm[k][dir_table];
                                
                                for(int j =0 ;j<8;j++)
                                {
                                    mm[j][pg_table]=0;
                                }
                                
                                free_pgs.push_back(pg_table);
                                mm[k][dir_table]=0;
                            }
                            
                        free_pgs.push_back(dir_table);
                        mm[i][del_id] = 0;
                   }
                   
                   else
                   {
                       for(int k=0; k<pid_pgsize[del_id]%8 ;k++)
                            {
                                int pg_table = mm[k][dir_table];
                                
                                if( k!= (pid_pgsize[del_id]%8) - 1)
                                {
                                    for(int j =0 ;j<8;j++)
                                    {
                                        mm[j][pg_table]=0;
                                    }
                                    free_pgs.push_back(pg_table);
                                }
                                
                                else
                                {
                                    for(int j =0 ;j< pid_prsize[del_id]%8 ;j++)
                                    {
                                        mm[j][pg_table]=0;
                                    }
                                    free_pgs.push_back(pg_table);
                                }
                                mm[k][dir_table]=0;
                            }
                        free_pgs.push_back(dir_table);
                        mm[i][del_id]=0;
                   }
                }
                cout<<"\n Multi-Level Deleted!!\n";
           }
           break; 
    
    	case 3:
            int trans_pid, line_no, va1, va2, pa, pg, line_pg,x,k1,k2;
            cout << "\nEnter the Process ID:\n";
            cin >> trans_pid;
            cout << "Enter the Line No:\n";
            cin >> line_no;
            pg = line_no / 8;
            line_pg = line_no % 8;
            
            if(pid_pgsize[trans_pid]<=8)
            {
            va1 = mm[pg][trans_pid];
            pa = ((va1 - 1) * 8) + line_pg;
            cout << "\nVirtual Add: " << va1;
            cout << "\tPhysical Add: " << pa;
            cout << endl<<endl;
            }
            
            else
            {
                if (line_no%8==0) x = line_no / 8;
                else x = line_no / 8 + 1;
                k1 = x / 8;
                k2 = x % 8;
                va2 = mm[k1][trans_pid];
                va1 = mm[k2-1][va2];
                pa = ((va1 - 1) * 8) + line_pg;
                cout << "\nVirtual Add L2: " << va2;
                cout << "\nVirtual Add L1: " << va1;
                cout << "\tPhysical Add: " << pa;
                cout << endl<<endl;
            }
            break;
    
    	case 4:
            for (int i = 0; i < 8; i++)
            {
                for (int j = 0; j < 128; j++)
                {
                    cout << mm[i][j] << " ";
                }
                cout << endl;
            }
            break;
            cout<<endl; 

    	case 5:
            exit (0);
    	}
}
return 0;
}


--------------------------------------------
LRU - SINGLE LEVEL - MULTI LEVEL
--------------------------------------------

--------------------------------------------
FIFO- SINGLE LEVEL - MULTI LEVEL
--------------------------------------------

--------------------------------------------
GARDEN AND GATE PROBLEM 
--------------------------------------------

# include <stdio.h>
# include <pthread.h>
#include <stdlib.h>
#include <semaphore.h> 
#include <unistd.h> 

# define LIMIT 15
 

 sem_t west_entry;
 sem_t east_entry;
 sem_t mutex;
 int west_count = 0;
 int east_count = 0;
 int total =0;
 
void *east_entry_fn(void *arg) 
{
    //  int i;
    //  i = ((int) arg);
	 sem_wait(&west_entry); 
	 sem_wait(&mutex); 
	 east_count++;
	 total++;
	 printf(" Entry from the East Gate!!\n");
     printf("West Count : %d \t East Count : %d\n", west_count, east_count );
	 printf(" Total :  %d\n", total);
	 sem_post(&mutex); 
	 sem_post(&west_entry); 
}

 void *west_entry_fn(void *arg) {
    
    //  int i;
    //  i = ((int) arg);
	 sem_wait(&east_entry); 
	 sem_wait(&mutex); 
	 west_count++;
	 total ++;
	 printf(" Entry from the West Gate!!\n");
	 printf("West Count : %d \t East Count : %d\n", west_count, east_count );
	 printf(" Total :  %d\n", total);
	 sem_post(&mutex); 
	 sem_post(&east_entry); 

 }
 
 
int main()
{    
    pthread_t ptid,ctid;
    
    for(int i = 0 ; i < LIMIT ; i++)
    {
    pthread_create(&ptid,NULL,east_entry_fn,NULL);
    pthread_create(&ctid,NULL,west_entry_fn,NULL);
    }
    
    sem_init(&west_entry, 0, 1); 
    sem_init(&east_entry, 0, 1);
    sem_init(&mutex, 0, 1);
    
    for(int i = 0; i < LIMIT ; i++)
    {
    pthread_join(ptid,NULL);
    pthread_join(ctid,NULL);
    }    
    
    return 0;
}

--------------------------------------------
CAR PARK PROBLEM
--------------------------------------------

# include <stdio.h>
# include <pthread.h>
#include <stdlib.h>
#include <semaphore.h> 
#include <unistd.h> 

# define MAX 15 //number of cars
# define SLOTS 10

int buff[SLOTS]={0};

 sem_t empty;
 sem_t full;
 sem_t mutex;
  
 int in = 0 ;
 
int it_exists(int buff[SLOTS] , int f)
{
    for(int i =0; i< SLOTS ;i++)
    {
        if(buff[i]==f)
        {
            return i;
        }
    }
    
 return 0;
}


void *arrival(void *arg) 
{
     int f;
     f = ((int) arg);
     sem_wait(&mutex); 
     
     printf("Car %d wishes to get parked!\n", f );
   	 
   	 if(in >= SLOTS ) 
   	 {
   	     sem_wait(&empty);
   	 }
	
	 buff[in] = f ;
	 printf("Car %d getting parked at %d \n",f , in++ );

	 
	 sem_post(&mutex); 
	 sem_post(&empty); 
}

 void *departure(void *arg) {
     
     int f;
     f = ((int) arg);
     
     if( it_exists(buff,f))
     {
     int pos = it_exists(buff,f);
     printf("Car %d  waiting to leave!\n", f );
     
     if(in <= 1)
     {
         sem_wait(&full);
     }
     
     printf("Car %d leaving from %d \n", f , pos );
     buff[pos]=0; 
     in -= 1;
     sem_post(&mutex); 
	 sem_post(&full); 
     }
 }
 
 
int main()
{    
    pthread_t ptid,ctid;
    
    for(int i = 1 ; i <= MAX ; i++)
    {
    pthread_create(&ptid,NULL,arrival,(void *)i);
    pthread_create(&ctid,NULL,departure, (void *)i);
    }
    
    sem_init(&full, 0, 0 ); 
    sem_init(&empty, 0, SLOTS);
    sem_init(&mutex, 0, 1);
    
    for(int i = 1; i <= MAX ; i++)
    {
    pthread_join(ptid,NULL);
    pthread_join(ctid,NULL);
    }    
    
    // for(int i=0;i<SLOTS ;i++)
    // {
    //     printf("%d",buff[i]);
    // }
    return 0;
}

--------------------------------------------
BUDDY ALLOCATOR
--------------------------------------------

#include<bits/stdc++.h>
using namespace std;
#define pb push_back
#define f first
#define s second

class Buddy{
vector<vector<pair<int,int> > > v;
map <int,int> m;
public: void buddy(int s)
  {

    int x = ceil(log2(s));
    v.resize(x+1);
    v[x].pb({0,s-1});
  }
  public: void allocate(int s)
  {
   
    int x = ceil(log2(s));
    cout<<x<<" ";
    pair<int,int> p;
    p.f =0;
    p.s =0;
    if(v[x].size()> 0)
    {
     p = v[x][0];
     v[x].erase(v[x].begin());
     cout<<"Memory from "<<p.f<<" to "<<p.s<<" allocated.\n";
     m[p.f] = p.s-p.f+1;
    return;
    }
    int i;
    for (i = x + 1; i < v.size(); i++) {
            if (v[i].size()==0)
                continue;
            break;  
        }
    if(i==v.size()){
     cout<<"Sorry, failed to allocate memory.\n";
     return;
    }
     p = v[i][0];
     v[i].erase(v[i].begin());
     i--;
      for (; i >= x; i--) {
            pair<int,int> t1;
                         t1 = {p.f, p.f  
                                     + (p.s - p.f) / 2};  
            pair<int,int> t2;
                     t2 = { p.f  + (p.s - p.f+1) / 2, p.s};  
            v[i].pb(t1);
            v[i].pb(t2);  
            p = v[i][0];
            v[i].erase(v[i].begin());
        }
      cout<<"Memory from"<<p.f<<" to "<<p.s<<" allocated.\n";
      m[p.f] = p.s-p.f+1;
      return;
     }
   public:  void deallocate(int s)
    {
        if (m[s]==0) {
            printf("Sorry, invalid free request\n");
            return;
        }
  int x = (int)ceil(log2(m[s])  
                                        /log2(2));
        int i, buddyNumber, buddyAddress;
  v[x].pb({s, s + (int)pow(2, x) - 1});
        cout<<"Memory block from "<< s<< " to "<<s + (int)pow(2, x) - 1<<" freed\n";
  buddyNumber = s / m[s];
     
        if (buddyNumber % 2 != 0) {
            buddyAddress = s - (int)pow(2, x);
        }
         
        else {
            buddyAddress = s + (int)pow(2, x);
        }
        for (i = 0; i < v[x].size(); i++) {
            if (v[x][i].f == buddyAddress) {
                if (buddyNumber % 2 == 0) {
                    v[x + 1].pb({s, s  
                                  + 2 * ((int)pow(2, x)) - 1});
                    cout<<"Coalescing of blocks starting at "<<s<<" and "<<buddyAddress<<" was done\n";
                }
                else {
                    v[x + 1].pb({buddyAddress,
                                    buddyAddress + 2 * ((int)pow(2, x))- 1});
                    cout<<"Coalescing of blocks starting at "<<buddyAddress<<" and "<<" was done\n";
                }
  v[x].erase(v[x].begin()+i);
                v[x].erase(v[x].begin()+v[x].size() - 1);
                break;
            }
        }
        m.erase(s);
    }
};



int main()
{
int initialMemory=0;
int val=0;
cout<<"Enter the initial memory size:";
cin>>initialMemory;
Buddy obj;
obj.buddy(initialMemory);
char ch='y';
while(ch=='y' || ch=='Y')
{
int mem,k;
cout<<"Allocate(0) or Deallocate(1)?";
cin>>k;
if(k==0)
{
cout<<"Enter the memory chunk to be allocated:";
cin>>mem;
obj.allocate(mem);
}
else
{
cout<<"Enter the memory chunk to be deallocated:";
cin>>mem;
obj.deallocate(mem);

}
cout<<"Want to enter more?(y/n):";
cin>>ch;
}
//cout<<"The final memory state:";
//obj.printrem();
return 0;
}


---------------------------------------------------------------------------
NAMED PIPES
---------------------------------------------------------------------------

#include<bits/stdc++.h>
#include <fcntl.h> 
#include <sys/stat.h> 
#include <sys/types.h> 
#include <unistd.h> 
using namespace std;
int main() 
{ 
    int fd1,fd2,N; 
    const char * myfifo1 = "/tmp/myfifo1"; 
   const char * myfifo2 = "/tmp/myfifo2"; 
    mkfifo(myfifo1, 0666);
	mkfifo(myfifo2, 0666); 
  cin>>N;
    int arr1[N], arr2[N],arr3[N]; 
        for(int i=0;i<N;i++)
		cin>>arr1[i];
        fd1 = open(myfifo1, O_WRONLY); 
        write(fd1, arr1,sizeof(arr2)); 
        close(fd1); 

  	fd2 = open(myfifo2, O_WRONLY); 
        write(fd2, arr1,sizeof(arr2)); 
        close(fd2);

        fd1 = open(myfifo1, O_RDONLY); 
        read(fd1, arr2, sizeof(arr2)); 
	cout<<"From program 1:\n";
		for(int i=0;i<N;i++)
		cout<<arr2[i]<<" ";
		cout<<endl;
        close(fd1);
	fd2 = open(myfifo2, O_RDONLY); 
        read(fd2, arr3, sizeof(arr3)); 
	cout<<"From program 2:\n";
		for(int i=0;i<N;i++)
		cout<<arr3[i]<<" ";
		cout<<endl;
        close(fd2);
    return 0; 
} 
--------------------------------------
#include<bits/stdc++.h>
#include <fcntl.h> 
#include <sys/stat.h> 
#include <sys/types.h> 
#include <unistd.h> 
using namespace std;
int main() 
{ 
    int fd3; 
  
    // FIFO file path 
    const char * myfifo = "/tmp/myfifo1"; 
    mkfifo(myfifo, 0666); 
int N;
cin>>N;
int ARR2[N];
        fd3 = open(myfifo,O_RDONLY); 
        read(fd3, ARR2,  sizeof(ARR2)); 
        close(fd3); 
sort(ARR2,ARR2+N);
        fd3 = open(myfifo,O_WRONLY); 
        write(fd3, ARR2, sizeof(ARR2)); 
        close(fd3); 
    return 0; 
} 
---------------------------------------
#include<bits/stdc++.h>
#include <fcntl.h> 
#include <sys/stat.h> 
#include <sys/types.h> 
#include <unistd.h> 
using namespace std;
int main() 
{ 
    int fd4; 
  
    // FIFO file path 
    const char * myfifo = "/tmp/myfifo2"; 
    mkfifo(myfifo, 0666); 
int N;
cin>>N;
int ARR3[N];
        fd4 = open(myfifo,O_RDONLY); 
        read(fd4, ARR3, sizeof(ARR3)); 
        close(fd4); 
        fd4 = open(myfifo,O_WRONLY); 
        write(fd4, ARR3, sizeof(ARR3)); 
        close(fd4); 
    return 0; 
} 

------------------------------------------------------------------------------
DEADLOCK OF 2 THREADS
------------------------------------------------------------------------------
#include <stdio.h> 
#include <pthread.h> 
#include <stdlib.h>

pthread_mutex_t read_mutex;
pthread_mutex_t write_mutex;

void * write(void *temp) {

pthread_mutex_lock(&write_mutex);
sleep(5);
pthread_mutex_lock(&read_mutex);
printf("\n LOCKED - WRITING !!\n");
pthread_mutex_unlock(&read_mutex);
pthread_mutex_unlock(&write_mutex);
printf("\n UNLOCKED !!\n");

}


void * read(void *temp) {

pthread_mutex_lock(&read_mutex);
sleep(5);
pthread_mutex_lock(&write_mutex);

printf("\n LOCKED - READING  !!\n");

pthread_mutex_unlock(&write_mutex);
pthread_mutex_unlock(&read_mutex);
printf("\n UNLOCKED !!\n");
}




int main() {

pthread_t thread_id,thread_id1;
pthread_create(&thread_id,NULL,&write,NULL);
pthread_create(&thread_id1,NULL,&read,NULL);
printf("\n Created 2 threads");
pthread_join(thread_id,NULL);
pthread_join(thread_id1,NULL);
// no output  ----> DEADLOCK
return 0;
}
----------------------------------------------------------------------------

#include <stdio.h> 
#include <pthread.h> 
#include <stdlib.h>

pthread_mutex_t read_mutex;
pthread_mutex_t write_mutex;


void * write(void *temp) {

pthread_mutex_lock(&write_mutex);
//sleep(5);
pthread_mutex_lock(&read_mutex);
printf("\n LOCKED - WRITING !!\n");
pthread_mutex_unlock(&read_mutex);
pthread_mutex_unlock(&write_mutex);
printf("\n UNLOCKED !!\n");

}


void * read(void *temp) {

pthread_mutex_lock(&write_mutex);
//sleep(5);
pthread_mutex_lock(&read_mutex);

printf("\n LOCKED - READING  !!\n");

pthread_mutex_unlock(&read_mutex);
pthread_mutex_unlock(&write_mutex);
printf("\n UNLOCKED !!\n");
}




int main() {

pthread_t thread_id,thread_id1;
pthread_create(&thread_id,NULL,&write,NULL);
pthread_create(&thread_id1,NULL,&read,NULL);
printf("\n Created 2 threads");
pthread_join(thread_id,NULL);
pthread_join(thread_id1,NULL);
// output  ----> removed DEADLOCK
return 0;
}


------------------------------------------------------------------------------
DEADLOCK OF 3 THREADS
------------------------------------------------------------------------------

#include <stdio.h> 
#include <pthread.h> 
#include <stdlib.h>

pthread_mutex_t read_mutex;
pthread_mutex_t write_mutex;
pthread_mutex_t display_mutex;


void * write(void *temp) {

pthread_mutex_lock(&write_mutex);
pthread_mutex_lock(&read_mutex);
pthread_mutex_lock(&display_mutex);
printf("\n LOCKED - WRITING !!\n");
pthread_mutex_unlock(&display_mutex);
pthread_mutex_unlock(&read_mutex);
pthread_mutex_unlock(&write_mutex);
printf("\n UNLOCKED !!\n");

}



void * read(void *temp) {

pthread_mutex_lock(&read_mutex);
pthread_mutex_lock(&display_mutex);
pthread_mutex_lock(&write_mutex);

printf("\n LOCKED - READING  !!\n");

pthread_mutex_lock(&write_mutex);
pthread_mutex_lock(&display_mutex);
pthread_mutex_lock(&read_mutex);
printf("\n UNLOCKED !!\n");
}



void * display(void *temp) {

pthread_mutex_lock(&display_mutex);
pthread_mutex_lock(&write_mutex);
pthread_mutex_lock(&read_mutex);

printf("\n LOCKED - Displaying  !!\n");

pthread_mutex_unlock(&read_mutex);
pthread_mutex_lock(&write_mutex);
pthread_mutex_unlock(&display_mutex);
printf("\n UNLOCKED !!\n");
}


int main() {

pthread_t thread_id,thread_id1, thread_id2;
pthread_create(&thread_id,NULL,&write,NULL);
pthread_create(&thread_id1,NULL,&read,NULL);
pthread_create(&thread_id1,NULL,&display,NULL);
printf("\n Created 3 threads");
pthread_join(thread_id,NULL);
pthread_join(thread_id1,NULL);
pthread_join(thread_id2,NULL);
// no output  ----> DEADLOCK
return 0;
}

--------------------------------------------------------------------------------------------
PRODUCER CONSUMER BY : SHARED MEMORY
--------------------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <semaphore.h>


int main()
{
    const char * name = "shared_memory";
    const char * sema1= "fill";
    const char * sema2= "avail";
    const char * sema3= "mutex";
    int shm_fd;   
    int * shelf;
    int loop = 5;
    sem_t * fill, * avail, * mutex;
    shm_fd = shm_open(name, O_CREAT | O_RDWR, 0666);
    ftruncate(shm_fd,sizeof(int));
    shelf = mmap(0,sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    fill = sem_open(sema1, O_CREAT,0666,0);
    avail = sem_open(sema2, O_CREAT, 0666, 3);
    mutex = sem_open(sema3,O_CREAT,0666,1);
    printf("\nProducing!\n");
    while(loop--){
        sem_wait(avail);
        sleep(rand()%2+1);
        sem_wait(mutex);
        (* shelf)++;
        sem_post(mutex);
        printf("Produced %d\n", * shelf);
        sem_post(fill);
    }
    printf(" Production Over !%d processes are left to be used.\n", * shelf);
    sem_close(fill);
    sem_close(avail);
    sem_close(mutex);
    sem_unlink(sema1);
    sem_unlink(sema2);
    sem_unlink(sema3);
      munmap(shelf, sizeof(int));
    close(shm_fd);
    shm_unlink(name);
    return 0;
}
------------------------------------PRODUCER_FILE------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <semaphore.h>
int main()
{
    const char * name = "shared_memory";
    const char * sema1= "fill";
    const char * sema2= "avail";
    const char * sema3="mutex";
    int shm_fd; 
    int * shelf;
    int loop = 5;
    sem_t * fill, * avail, * mutex;
    shm_fd = shm_open(name, O_RDWR, 0666);
    shelf = mmap(0,sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    fill = sem_open(sema1, O_CREAT,0666,0);
    avail = sem_open(sema2, O_CREAT, 0666, 3);
    mutex = sem_open(sema3,O_CREAT,0666,1);
    while(loop--){
        sem_wait(fill);
        sleep(rand()%2+1);
        sem_wait(mutex);
        int t = *shelf;
        (* shelf)--;
        sem_post(mutex);
        printf(" Used process %d!\n",t);
        sem_post(avail);
    }
    sem_close(fill);
    sem_close(avail);
    sem_close(mutex);
    sem_unlink(sema1);
    sem_unlink(sema2);
    sem_unlink(sema3);
    munmap(shelf, sizeof(int));
    close(shm_fd);
    shm_unlink(name);
    return 0;
}
-----------------------------------------------------------CONSUMER FILE-----------------------------------------------------

----------------------------------------------------------------------
RACE CONDITION AVOIDANCE BY SEMAPHORE
----------------------------------------------------------------------

#include <stdio.h> 
#include <pthread.h> 
#include <semaphore.h> 
#include <unistd.h> 
  
sem_t s; 
static volatile int counter = 0;

void* thread(void* arg) 
{ 
    //wait 
    sem_wait(&s); 
    printf("%s: begin\n",(char *) arg);
  
    int i;
	for(i=0;i<10000000;i++) {
	counter =counter + 1;
	}
      
    //signal 
    printf("%s: done\n", (char *) arg); 
    sem_post(&s); 
} 
  
  
int main() 
{ 
    sem_init(&s, 0, 1); 
    pthread_t t1,t2; 
    printf("main: begin (counter = %d)\n", counter);
    pthread_create(&t1,NULL,thread,"A"); 
    sleep(2); 
    pthread_create(&t2,NULL,thread,"B"); 
    pthread_join(t1,NULL); 
    pthread_join(t2,NULL); 
    printf("main: done with both (counter = %d)\n", counter);
    sem_destroy(&s); 
    return 0; 
} 

--------------------------------------------------------------------------------------------------------
---------------------------------------
LRU IMPLEMENTATION
--------------------------------------

#include<bits/stdc++.h>
#include <iostream>
#include <set>
#include <iterator>
using namespace std;
 

void LRU(int pages[], int n, int capacity)
{
   
    unordered_set<int> s;
 
 
    unordered_map<int, int> indexes;
 
   
 
    for (int i=0; i<n; i++)
    {
       
        if (s.size() < capacity)
        {
           
            if (s.find(pages[i])==s.end())
            {
                s.insert(pages[i]);
  unordered_set<int>::iterator it;
 
  for(it=s.begin();it!=s.end();it++)
  {
  cout<<*it <<"\t";
  }
               
               cout<<endl;
               
            }
 
           
            indexes[pages[i]] = i;
        }
 
       
        else
        {
           
            if (s.find(pages[i]) == s.end())
            {
                cout << "Page Replacement needed ! \n";
                int lru = INT_MAX, val;
               
                for (auto it=s.begin(); it!=s.end(); it++)
                {
                    if (indexes[*it] < lru)
                    {
                        lru = indexes[*it];
                        val = *it;
                    }
                }
 
               
                s.erase(val);
               
                s.insert(pages[i]);
 
                unordered_set<int>::iterator it;
 
  for(it=s.begin();it!=s.end();it++)
  {
  cout<<*it <<"\t";
  }
 
  cout<<endl;
               
            }
 
           
            indexes[pages[i]] = i;
        }
    }
 
   
}
 
// Driver code
int main()
{
    int n,cap;
    int arr[10];
    cout<< "Enter number of pages : \t" ;
    cin>>n;
    cout<<"\n";
    cout<< "Capacity : \t";
    cin>>cap;
    cout<<"\n";
    int i;
    for(i=0;i<n;i++)
    {
  cin>>arr[i];
  }  
   
   
    LRU(arr, n, cap);
    return 0;
} 

-----------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------
THREADS RACE : MATRIX MULTIPLICATION 
------------------------------------------------------------------
#include<stdio.h>
#include<assert.h>
#include<pthread.h>

static volatile int counter = 0;

void*  mythread(void *arg)
{
	printf("%s: begin\n",(char *) arg);
	int i;
	for(i=0;i<10000000;i++) {
	counter =counter + 1;
	}
	printf("%s: done\n", (char *) arg);
	return NULL;
}



int main (int argc, char *argv[])
{
	pthread_t p1,p2;
	printf("main: begin (counter = %d)\n", counter);
	pthread_create(&p1, NULL, mythread, "A");
	pthread_create(&p2, NULL, mythread, "B");
	
	pthread_join(p1,NULL);
	pthread_(p2,NULL);
	printf("main: done with both (counter = %d)\n", counter);
	return 0;
}
--------------------------------------------------------------------------

#include <bits/stdc++.h> 
using namespace std; 
  
 
  
int A[3][3]; 
int B[3][3]; 
int C[3][3]; 
int var = 0; 
  
void* multiply_func(void* arg) 
{ 
    int core = var++; 

    for (int i = core ; i < (core + 1) ; i++)  
        for (int j = 0; j < 3; j++)  
            for (int k = 0; k < 3; k++)  
                C[i][j] += A[i][k] * B[k][j]; 
} 
  

int main() 
{ 


  srand(time(0)); 

    for (int i = 0; i < 3; i++) { 
        for (int j = 0; j < 3; j++) { 
            A[i][j] = rand() % 10; 
            B[i][j] = rand() % 10; 
        } 
    } 
    cout << endl << "A : " << endl; 
    
    for (int i = 0; i < 3; i++) { 
        for (int j = 0; j < 3; j++)  
            cout << A[i][j] << " "; 
        cout << endl; 
    } 

		cout << endl<< "B : " << endl; 
		
    for (int i = 0; i < 3; i++) { 
        for (int j = 0; j < 3; j++)  
            cout << B[i][j] << " ";         
        cout << endl; 
    } 
    
    pthread_t threads[3]; 
   
    for (int i = 0; i < 3; i++) { 
        int* p; 
        pthread_create(&threads[i], NULL, multiply_func, (void*)(p)); 
    } 
  
    for (int i = 0; i < 3; i++)  
        pthread_join(threads[i], NULL);     
  
    cout << endl << "Product of A and B" << endl; 
    
    for (int i = 0; i < 3; i++) { 
        for (int j = 0; j < 3; j++)  
            cout << C[i][j] << " ";         
        cout << endl; 
    } 
    return 0; 
} 

------------------------------------------------------------------------------------------------------------------------------

--------------------------------------------------------------
PIPES : SORT/ NOT SORTED
--------------------------------------------------------------

/*
#include<stdio.h>
#include<unistd.h>

int main() {

   int pipefds[2];
   int returnstatus;
   char write s[2][20]={"Hi", "Hello"};
   char read [20];
   returnstatus = pipe(pipefds);
   
   if (returnstatus == -1) {
      printf("Unable to create pipe\n");
      return 1;
   }
   
   printf("Writing to pipe - Array 1  \n", write s[0]);
   write(pipefds[1], write s[0], sizeof(write s[0]));
   read(pipefds[0], read , sizeof(read ));
   printf("Reading from pipe – Array 1  \n", read );
   printf("Writing to pipe - Array 2  \n", write s[1]);
   write(pipefds[1], write s[1], sizeof(write s[1]));
   read(pipefds[0], read , sizeof(read ));
   printf("Reading from pipe – Array 2  \n", read );
   return 0;
}

#include<stdio.h>
#include<unistd.h>

int main() {
   int pipefds[2];
   int returnstatus;
   int  pid1;
   char write s[2][20]={"Hi", "Hello"};
   char read [20];
   returnstatus = pipe(pipefds);
   if (returnstatus == -1) {
      printf("Unable to create pipe\n");
      return 1;
   }
    pid1 = fork();
   
   // Child process
   if ( pid1 == 0) {
      read(pipefds[0], read , sizeof(read ));
      printf("Child Process - Reading from pipe – Array 1  \n", read );
      read(pipefds[0], read , sizeof(read ));
      printf("Child Process - Reading from pipe – Array 2  \n", read );
   } else { //Parent process
      printf("Parent Process - Writing to pipe - Array 1  \n", write s[0]);
      write(pipefds[1], write s[0], sizeof(write s[0]));
      printf("Parent Process - Writing to pipe - Array 2  \n", write s[1]);
      write(pipefds[1], write s[1], sizeof(write s[1]));
   }
   return 0;
}
*/

#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
#include<sys/wait.h>


void merge(int arr[], int l, int m, int r) 
{ 
    int i, j, k; 
    int n1 = m - l + 1; 
    int n2 =  r - m; 
  
    /* create temp arrays */
    int L[n1], R[n2]; 
  
    /* Copy data to temp arrays L[] and R[] */
    for (i = 0; i < n1; i++) 
        L[i] = arr[l + i]; 
    for (j = 0; j < n2; j++) 
        R[j] = arr[m + 1+ j]; 
  
    /* Merge the temp arrays back into arr[l..r]*/
    i = 0; // Initial index of first subarray 
    j = 0; // Initial index of second subarray 
    k = l; // Initial index of merged subarray 
    while (i < n1 && j < n2) 
    { 
        if (L[i] <= R[j]) 
        { 
            arr[k] = L[i]; 
            i++; 
        } 
        else
        { 
            arr[k] = R[j]; 
            j++; 
        } 
        k++; 
    } 
  
    /* Copy the remaining elements of L[], if there 
       are any */
    while (i < n1) 
    { 
        arr[k] = L[i]; 
        i++; 
        k++; 
    } 
  
    /* Copy the remaining elements of R[], if there 
       are any */
    while (j < n2) 
    { 
        arr[k] = R[j]; 
        j++; 
        k++; 
    } 
} 
  
/* l is for left index and r is right index of the 
   sub-array of arr to be sorted */
void mergeSort(int arr[], int l, int r) 
{ 
    if (l < r) 
    { 
        // Same as (l+r)/2, but avoids overflow for 
        // large l and h 
        int m = l+(r-l)/2; 
  
        // Sort first and second halves 
        mergeSort(arr, l, m); 
        mergeSort(arr, m+1, r); 
  
        merge(arr, l, m, r); 
    } 
} 


int main() {
   int pipefds1[2], pipefds2[2],pipefds3[2],pipefds4[2];
   int returnstatus1, returnstatus2,returnstatus3,returnstatus4;
   int pid1,pid2;
   //char pipe1write [20] = "Hi";
   //char pipe2write [20] = "Hello";
   //char read [20];
   int write1[5] = {2,-1,5,3,10};
   int write2[5],write3[5],i;
	int read1[5],read2[5]; 
   returnstatus1 = pipe(pipefds1);
   
   if (returnstatus1 == -1) {
      printf("Unable to create pipe 1 \n");
      return 1;
   }
   returnstatus2 = pipe(pipefds2);
   
   if (returnstatus2 == -1) {
      printf("Unable to create pipe 2 \n");
      return 1;
   }
   returnstatus3 = pipe(pipefds3);
   
   if (returnstatus3 == -1) {
      printf("Unable to create pipe 3 \n");
      return 1;
   }
   
   returnstatus4 = pipe(pipefds4);
   
   if (returnstatus4 == -1) {
      printf("Unable to create pipe 4 \n");
      return 1;
   }
   
   pid1 = fork();
   if( pid1!=0) pid2 = fork();
   
   if ( pid1 != 0 && pid2!=0 ) 
	{            // Parent process
      close(pipefds1[0]); // Close the unwanted pipe1 read side
      close(pipefds2[1]); // Close the unwanted pipe2 write side
      close(pipefds3[0]); // Close the unwanted pipe3 read side
      close(pipefds4[1]); // Close the unwanted pipe4 write side
      printf("In Parent: Writing to pipe 1 – Array \n");
      for(i=0;i<5;i++) printf("\t%d",write1[i]);
      write(pipefds1[1], write1, sizeof(write1));
      printf("\nIn Parent: Writing to pipe 3 – Array \n");
      for(i=0;i<5;i++) printf("\t%d",write1[i]);
      write(pipefds3[1], write1, sizeof(write1));
      
      int wc= wait(NULL);
      read(pipefds2[0], read1, sizeof(read1));
      printf("\nIn Parent: Reading from pipe 2 – Array \n");
      for(i=0;i<5;i++) printf("\t%d",read1[i]);
      read(pipefds4[0], read2, sizeof(read2));
      printf("\nIn Parent: Reading from pipe 4 – Array \n");
      for(i=0;i<5;i++) printf("\t%d",read2[i]);
      int flag1=0,flag2=0;
      for(i=1;i<5;i++)
      {
      	if(read1[i]<read1[i-1])
      	{ 
		   	flag1 = 1;
		   	printf("\nsorted array nahi hein :(\n"); 
		   	break;
      	}
      } 
      if(flag1==0) printf("\nsorted array milgayi :)\n");

      for(i=1;i<5;i++)
      {
      	if(read2[i]<read2[i-1])
      	{ 
		   	flag2 = 1;
		   	printf("\nsorted array nahi hein :(\n"); 
		   	break;
      	}
      } 
      if(flag2==0) printf("\nsorted array milgayi :)\n");
   } 
else if(pid1==0) 
		{
		 //child process
      close(pipefds1[1]); // Close the unwanted pipe1 write side
      close(pipefds2[0]); // Close the unwanted pipe2 read side
      read(pipefds1[0], read1 , sizeof(read1));
      printf("\nIn Child: Reading from pipe 1 – Array \n");
      mergeSort(read1,0,4);
      for(i=0;i<5;i++)
      {
      	write2[i]=read1[i];
      }
      printf("\nIn Child: Writing to pipe 2 – Array \n");
      write(pipefds2[1], write2 , sizeof(write2));
   }
   else if(pid2==0) 
		{
		 //child process
      close(pipefds3[1]); // Close the unwanted pipe1 write side
      close(pipefds4[0]); // Close the unwanted pipe2 read side
      read(pipefds3[0], read2 , sizeof(read2));
      printf("\nIn Child: Reading from pipe 3 – Array \n");
      mergeSort(read1,0,0);
      for(i=0;i<5;i++)
      {
      	write3[i]=read2[i];
      }
      printf("\nIn Child: Writing to pipe 4 – Array \n");
      write(pipefds4[1], write3 , sizeof(write3));
   }
   return 0;
}

------------------------------------------------------------------------
SYSTEMS CALL - FORK EXEC ---
------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *argv[]){
	printf("helloworld (pid:%d)\n", (int) getpid());
	int rc = fork();
	if(rc<0){
		fprintf(stderr,"fork failed\n");
		exit(1);
	} else if(rc==0){
		printf("hello, I am child (pid:%d)\n", (int) getpid());
	} else{
		printf("hello, I am parent of %d (pid:%d)\n",rc, (int) getpid());
	}
return 0;
}
----------------------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>


int main(int argc, char *argv[]){
	printf("helloworld (pid:%d)\n", (int) getpid());
	int rc = fork();
	if(rc<0){
		fprintf(stderr,"fork failed\n");
		exit(1);
	} else if(rc==0){
		printf("hello, I am child (pid:%d)\n", (int) getpid());
	

	char *myargs[3];
	myargs[0] = strdup("wc");
	myargs[1] = strdup("txt");
	myargs[2] = NULL;
	execvp(myargs[0], myargs);
	printf("this shouldn't print out");
	} else{
		int wc=wait(NULL);
	printf("hello, I am parent of %d (wc:%d) (pid:%d)\n",rc,wc, (int) getpid());
	}
return 0;
}
----------------------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>


int main(int argc, char *argv[]){
	printf("helloworld (pid:%d)\n", (int) getpid());
	int rc = fork();
	if(rc<0){
		fprintf(stderr,"fork failed\n");
		exit(1);
	} else if(rc==0){
		printf("hello, I am child (pid:%d)\n", (int) getpid());
	} else{
		int wc=wait(NULL);
	printf("hello, I am parent of %d (wc:%d) (pid:%d)\n",rc,wc, (int) getpid());
	}
return 0;
}

----------------------------------------------------------------------------------------

